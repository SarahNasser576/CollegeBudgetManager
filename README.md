# College Budget Manager

Sarah Nasser \
sarahnasser576@gmail.com 

Explanation of my program and how to use it: \
This program plays a simulation in which the user takes the role of a college freshman who has to manage their semesterly budget while also paying for their needs and wants. The objective of this program is to help college students better understand how to manage a budget. This simulation contains many prompts or situations that college students commonly encounter, such as being pressured to buy designer clothes, buying groceries, making plans for Halloween, having fun on Black Friday, and buying gifts for friends in addition to bathroom supplies. For each situation, the user will enter input for numerous questions, for example if the program asks the user whether they want to buy a new phone. In order to win this simulation or game, you need to make it to the end of the semester while having a non-negative budget. You will lose the game if at some point, your budget becomes negative, or if your budget becomes zero before the end of the semester. All instructions are enclosed in the simulation once you run it.

Decisions I made while writing my code: \
In the CollegeBudgetManager class, I wrote a constructor that declares and initializes the budget to 5000. After introducing the simulation in my program, I decided on seven scenarios for the simulation: shopping for clothes, going grocery shopping, having fun on Halloween, buying bathroom supplies, going Black Friday shopping, buying a coat, and doing Secret Santa. In my main method, I called methods corresponding to these scenarios.

For the scenario in which the college student shops for clothes, I wrote a method called goShopping, which takes in the variable budget as a parameter. Through user input, the user is first asked whether they want to buy better clothes like their classmates'. I also declared and initialized the variable clothesLeft to True. This variable will represent whether there are clothes left for the college student to buy. If the user responds yes and wants to buy clothes, the lists, dresses, purses, pants, shoes, skirts, and shirts are declared and initialized. dresses is initialized to the list returned by the method addDresses, which takes in dresses as a parameter. purses is initialized to the list returned by the method addPurses, which takes in purses as a parameter. pants is initialized to the list returned by the method addPants, which takes in pants as a parameter. shoes is initialized to the list returned by the method addShoes, which takes in pants as a parameter. skirts is initialized to the list returned by the method addSkirts, which takes in skirts as a parameter. shirts is initialized to the list returned by the method addShirts, which takes in shirts as a parameter. addDresses appends dresses to the list dresses, addPurses appends purses to the list purses, addPants appends pants to the list pants, addShoes appends shoes to the list shoes, addSkirts appends skirts to the list skirts, and addShirts appends shirts to the list shirts. Next I declared the variable clothingArticles and initialized it to a list containing the strings, "dresses," "purses," "pants," "shoes," "skirts," and "shirts." I also declared the variable chooseClothes and initialized it to the boolean value True. This variable indicates whether the user wants to continue shopping. I then wrote a while loop, its condition being that the values of both chooseClothes and clothesLeft are True. Inside the while loop, I listed the clothing articles options by calling the method listToString with the list clothingArticles. listToString writes the string representation of a list. It returns a string concatenating "[," all the elements in clothingArticles connected by commas (I used .join(str(i) for every element i in the list), and "]." I then let the user input which clothing article they want to buy. For each clothing article, I called its associated method in which the user buys an item of that article. This method for dresses, for example, is buyDress. buyDress takes in budget and the list dresses as its parameters, and inside that method, I gave the user the dresses options using the string representation returned by listToString. I then included conditional statements for each dress in the list of dresses. I have chosen costs for each dress, and I have made them clear for the user. In each conditional statement (which one gets called depends on which dress the user types as input), I decreased budget appropriately and popped that dress from the list. If the user types anything that is not a dress in the list (case sensitive), I printed an appropriate message that the input is invalid. Going back to the while loop in the goShopping method, if there is no more in stock for a clothing article (if the length of a list is 0), I simply pop the clothing article from the list of clothing articles. If the user types anything that is not a clothing srticle from the list, I printed that their input is invalid. Each time after the user buys a clothing item, I printed their updated budget. Then I included conditionals regarding whether there are no more clothing articles (whether len(clothingArticles) is greater than 0). If there are still clothing articles left, I let the user input whether they want to continue shopping. If the user does not want to, I updated the value of chooseClothes to False, terminating the while loop. If there are no clothing articles left, I updated the value of clothesLeft to False, also terminating the while loop. At the end of goShopping, I returned budget.

For the scenario in which the user goes grocery shopping, I created the method buyGroceries, which takes in the parameter budget. Inside this method I declared the list foodItems and initialized it to the list returned by addFoodItems. addFoodItems, which takes in the parameter foodItems, appends food items to foodItems. Next in buyGroceries, I declared the variable continueBuying and initialized it to the boolean value True. This variable indicates whether the user wants to continue buying food. I then wrote a while loop that runs while the value of continueBuying is true and len(foodItems) > 0 (meaning that there are still foodItems left). Inside this while loop, I used listToString to show the user all the food options with the costs, and I let them input what they want to buy. I updated the value of budget to the budget returned by the method chooseFoodItems, which takes budget, the user input, and foodItems as its parameters. In this method, I wrote conditionals that indicate what the user wants to buy. The body of each conditional is that I decrease the budget appropriately and pop the food item from the list of food items. After updating the value of budget in buyGroceries, I printed the user's current budget. I then wrote a conditional stating that if there are food items left, the user will be asked whether they want to continue grocery shopping. If the user does not want to, I updated the value of continueBuying to False, terminating the while loop. After this while loop, I returned budget.

For the scenario in which the user has fun on Halloween, I created the method haveFunOnHalloween, which takes in the parameter budget. In this method, I declared the list halloweenOptions and initialized it to the list returned by the method addHalloweenOptions, which takes in the parameter halloweenOptions and appends options to the list. I also declared the variable validOptionPicked and initialized it to the boolean value False. Then I wrote a while loop that runs while the value of validOptionPicked is false (while the user types something that is not in the list of Halloween options). Even if the user types invalid input, they will get another chance to type valid input. Inside this while loop, I printed the options with the costs and let the user input what they want to do for Halloween. I then wrote a big conditional covering the case in which the user inputted something that is in the list of options. Inside this conditional, I updated the value of validOptionPicked to True, which will later terminate the while loop. I also wrote numerous smaller conditionals that covers each option the user might pick. Each conditional decreases the budget appropriately. Outside of the big conditional, I wrote an else statement, which runs if the user inputs something that is not in the list of options. In this else statement, I printed to the user that their input is invalid.

For the scenario in which the user has to buy bathroom supplies, namely towels, tooth brushes, and shower curtain, I created the method buyBathroomSupplies, where I called the methods buyTowel, buyToothBrush, and buyShowerCurtain. In each of these three methods, I let the user input whether they want to buy new towels, tooth brushes, and shower curtains. If the user wants to, I declared the variable validOptionPicked and initialized it to the boolean value False. This variable indicates whether the user typed valid input, and the while loop I wrote runs only when the value of validOptionPicked is False. The purpose of this while loop is to give the user another chance in case they wrote invalid input, anything that is not in the lists of these bathroom supplies. How I checked for valid input varied between these three methods. In buyTowel and buyShowerCurtain, since I only gave the user two options each for a towel and shower curtain, I wrote a big conditional stating that if the user input is any of the two strings I instructed them to type to indicate what option they pick, the value of validOptionPicked is updated to True, terminating the while loop later. Inside that big conditional, I also wrote two smaller conditionals for these options in which I decreased the budget appropriately. In buyToothBrushes, before the while loop, I declared a list toothbrushes and initialized it to the list returned by the method addToothBrushes, which appends tooth brushes to the list toothbrushes. Inside the while loop, I checked whether user input is valid by checking whether the user input is a tooth brush in the list. I used a list in this method because I gave the user four options as to what tooth brush they can buy. I updated the value of validOptionPicked to True, and for each conditional (for each possible toothbrush the user might choose to buy), I decreased the budget appropriately. If the user input is not in the list of tooth brushes, I printed that the input is invalid. At the end of all three of these methods, I printed the current budget and returned it.

For the scenario in which the user decides whether to go shopping on Black Friday, I created the method blackFriday. Inside this method, I let the user input whether they want to go shopping on Black Friday. If the user wants to, I let them input whether they want a new phone or laptop. If the user wants both, I called the methods buyPhone, buyPhoneCase, and buyLaptop. If the user wants to puy a phone, I called the methods buyPhone and buyPhoneCase. If the user wants to buy a laptop, I called the method buyLaptop. One of the major differences between these three methods is that at the beginning of buyPhoneCase, I let the user input whether they want to buy a phone case, and I only decreased their budget if they choose to buy one. In all three of these methods, I used the same logic from the buyToothBrushes method. There are only a few differences: I used lists of phones, phone cases, and laptops instead and used methods to append to them. I checked if user input is in those lists. If it is, I wrote smaller conditionals for each phone, phone case, and laptop the user might buy, decreasing the budget appropriately. Otherwise I printed that the user input is invalid.

For the scenario in which the user decides whether to buy a new coat, I created the method buyCoat, where I used almost the same logic that I used in the buyPhoneCase method, except for a few differences: I declared the list coats and initialized it to the list returned by the method addCoats, which appends coats to the list and then returns it. Every reference pertaining to the list of tooth brushes and its elements have been rewritten so that they pertain to the list of coats. After printing the user's current budget, I called the method checkIfDebt.

For the scenario in which the user does Secret Santa, I created the method secretSanta. The logic I used in this method is almost the same as the logic that I used in the buyPhone and buyLaptop methods, except for a few differences: I declared the list gifts and initialized it to the list returned by the method addGifts, which appends gifts to the list and then returns it. Every reference pertaining to the lists of phones and laptops have been rewritten so that they pertain to the list of gifts. I called the helper method buyGift to decrease the budget appropriately for each gift. I decided to use a helper method instead of putting it all in secretSanta because the list of gifts is longer. Next I call the method checkIfDebt, in case the user's budget is 0

gave them the options for coats. I then used the same 

In buyPhone, I declared the list phones and initialized it to the list returned by the method addPhones, which appends the types of phones to phones and then returns phones. I then let the user input what type of phone they want to
